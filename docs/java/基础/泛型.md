# 泛型

> List ：存的时候只能选一个类型。

1. List <? extends Fruit> 意思： List中所有元素都是Fruit的子类(包含本身)，

2. List <? super Fruit> 意思： List中所有元素都是Fruit的父类(包含本身)

3. List <? extends Fruit>假设：Fruit有子类A、B、C 那么 list.add(A);list.add(B);list.add(C);显然错误(不能存多个类)。

虽然我们现在看的是ABC3个类就会问为什么会把不同类型的存进去，我这样存不就好了？list.add(A);list.add(A);其实这也是错误的，因为在运行之前它可不知道你到底add进去的东西是什么类型，是一样还是不一样，因实例化的时候是 ? 待定。为了避免类型不同的情况，所以会编译不通过。

4. List <? super Fruit>假设：Fruit有子类A、B、C 那么 list.add(A);list.add(B);list.add(C); 这却是可以的，为什么呢：
因为它是这么存的：list.add((Fruit)A);list.add((Fruit)B); **自动强转了。因为小转大是隐性的，大转小才是强转需要加类型。**

那这里为什么又不能存Fruit的父类呢？ 因为见假设1，它是？号，类型代表待定，不跑起来它也不知道你到底存的什么。所以我们能手动add()进去的数据都必须是绝对安全的(最低级父类:本身)才能通过。所以直接add父类也是不行的。

5. 当方法中不需要改变容器时，用通配符，否则用泛型方法，当方法中其他参数，返回值与泛型参数具有依赖关系，使用泛型方法